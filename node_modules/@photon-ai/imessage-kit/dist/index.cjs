'use strict';

var fs = require('fs');
var os = require('os');
var path = require('path');
var child_process = require('child_process');
var util = require('util');

// src/plugins/core.ts
var PluginManager = class {
  /** List of registered plugins */
  plugins = [];
  /** Whether the plugin manager has been initialized */
  initialized = false;
  /**
   * Register a plugin
   * If the manager is already initialized, the plugin's onInit hook will be called immediately
   * @param plugin Plugin instance
   * @returns this - Supports method chaining
   */
  use(plugin) {
    this.plugins.push(plugin);
    if (this.initialized && plugin.onInit) {
      Promise.resolve(plugin.onInit()).catch((error) => {
        const errorMsg = `[Plugin ${plugin.name}] Initialization failed:`;
        console.error(errorMsg, error);
      });
    }
    return this;
  }
  /**
   * Initialize all plugins
   * Calls the onInit hook for all plugins
   */
  async init() {
    this.initialized = true;
    await this.callHookForAll("onInit");
  }
  /**
   * Destroy all plugins
   * Calls the onDestroy hook for all plugins and clears the plugin list
   */
  async destroy() {
    await this.callHookForAll("onDestroy");
    this.plugins = [];
    this.initialized = false;
  }
  /**
   * Call the specified hook for all plugins
   * @param hookName Hook name
   * @param args Hook arguments
   * @returns List of plugin errors (if any)
   */
  async callHookForAll(hookName, ...args) {
    const pluginsWithHook = this.plugins.filter((p) => p[hookName]);
    if (pluginsWithHook.length === 0) {
      return [];
    }
    const results = await Promise.allSettled(
      pluginsWithHook.map(async (plugin) => {
        try {
          const hook = plugin[hookName];
          const hookFn = hook;
          await Promise.resolve(hookFn(...args));
          return {
            plugin: plugin.name,
            success: true
          };
        } catch (error) {
          const normalizedError = error instanceof Error ? error : new Error(String(error));
          return {
            plugin: plugin.name,
            success: false,
            error: normalizedError
          };
        }
      })
    );
    const errors = [];
    for (const result of results) {
      if (result.status === "fulfilled" && !result.value.success) {
        errors.push({
          plugin: result.value.plugin,
          error: result.value.error
        });
      } else if (result.status === "rejected") {
        const normalizedError = result.reason instanceof Error ? result.reason : new Error(String(result.reason));
        errors.push({
          plugin: "unknown",
          error: normalizedError
        });
      }
    }
    if (errors.length > 0 && hookName !== "onError") {
      for (const { plugin, error } of errors) {
        console.error(`[Plugin ${plugin}] ${hookName} failed:`, error);
        try {
          const context = `Plugin ${plugin} - ${String(hookName)}`;
          await this.callHookForAll("onError", error, context);
        } catch {
        }
      }
    }
    return errors;
  }
};
var definePlugin = (plugin) => plugin;

// src/types/advanced.ts
var PHONE_REGEX = /^\+?[\d\s\-()]+$/;
var EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
var URL_REGEX = /^https?:\/\/.+/;
var asRecipient = (value) => {
  const normalized = value.trim();
  if (!normalized) {
    throw new TypeError("Recipient cannot be empty");
  }
  if (PHONE_REGEX.test(normalized) || EMAIL_REGEX.test(normalized)) {
    return normalized;
  }
  throw new TypeError(`Invalid recipient format: ${value} (phone number or email required)`);
};
var isURL = (value) => {
  return URL_REGEX.test(value);
};

// src/core/errors.ts
var IMessageError = class _IMessageError extends Error {
  constructor(code, message) {
    super(message);
    this.code = code;
    this.name = "IMessageError";
    Error.captureStackTrace?.(this, this.constructor);
  }
  /** Type guard */
  static is(error) {
    return error instanceof _IMessageError;
  }
  /** Check if error is of specific type */
  is(code) {
    return this.code === code;
  }
};
var PlatformError = (msg = "Only macOS is supported") => new IMessageError("PLATFORM", msg);
var DatabaseError = (msg) => new IMessageError("DATABASE", msg);
var SendError = (msg) => new IMessageError("SEND", msg);
var WebhookError = (msg) => new IMessageError("WEBHOOK", msg);
var ConfigError = (msg) => new IMessageError("CONFIG", msg);

// src/utils/platform.ts
var requireMacOS = () => {
  if (process.platform !== "darwin") {
    throw PlatformError("Only macOS is supported");
  }
};
var isMacOS = () => {
  return process.platform === "darwin";
};
var getDefaultDatabasePath = () => {
  const home = process.env.HOME;
  if (!home) {
    throw new Error("HOME environment variable is not set");
  }
  return `${home}/Library/Messages/chat.db`;
};
var TEMP_FILE_PREFIX = "imsg_temp_";
var TEMP_DIR = path.join(os.homedir(), "Pictures");
var DEFAULT_CONFIG = {
  /** File retention time (milliseconds), default 10 minutes */
  maxAge: 10 * 60 * 1e3,
  /** Cleanup interval (milliseconds), default 5 minutes */
  cleanupInterval: 5 * 60 * 1e3
};
var TempFileManager = class {
  config;
  cleanupTimer = null;
  isDestroyed = false;
  constructor(config = {}) {
    this.config = {
      maxAge: config.maxAge ?? DEFAULT_CONFIG.maxAge,
      cleanupInterval: config.cleanupInterval ?? DEFAULT_CONFIG.cleanupInterval,
      debug: config.debug ?? false
    };
  }
  /**
   * Start cleanup task
   */
  start() {
    if (this.isDestroyed) {
      throw new Error("TempFileManager is destroyed, cannot start");
    }
    this.cleanup().catch((error) => {
      if (this.config.debug) {
        console.error("[TempFileManager] Startup cleanup failed:", error);
      }
    });
    this.cleanupTimer = setInterval(() => {
      this.cleanup().catch((error) => {
        if (this.config.debug) {
          console.error("[TempFileManager] Periodic cleanup failed:", error);
        }
      });
    }, this.config.cleanupInterval);
    this.cleanupTimer.unref();
    if (this.config.debug) {
      const intervalSec = this.config.cleanupInterval / 1e3;
      const maxAgeSec = this.config.maxAge / 1e3;
      console.log(
        `[TempFileManager] Started, cleanup interval: ${intervalSec}s, max file retention: ${maxAgeSec}s`
      );
    }
  }
  /**
   * Clean up old temporary files
   *
   * By scanning ~/Pictures directory,
   * auto-discover and clean all imsg_temp_* files exceeding retention time
   */
  async cleanup() {
    if (this.isDestroyed) {
      return { removed: 0, errors: 0 };
    }
    let removed = 0;
    let errors = 0;
    const now = Date.now();
    try {
      if (fs.existsSync(TEMP_DIR)) {
        const files = fs.readdirSync(TEMP_DIR);
        for (const file of files) {
          if (!file.startsWith(TEMP_FILE_PREFIX)) {
            continue;
          }
          const filePath = path.join(TEMP_DIR, file);
          try {
            const stats = fs.statSync(filePath);
            const fileAge = now - stats.mtimeMs;
            if (fileAge > this.config.maxAge) {
              fs.unlinkSync(filePath);
              removed++;
              if (this.config.debug) {
                const ageMinutes = (fileAge / 6e4).toFixed(1);
                console.log(`[TempFileManager] Removed old file: ${file} (${ageMinutes} minutes ago)`);
              }
            }
          } catch (error) {
            errors++;
            if (this.config.debug) {
              console.error(`[TempFileManager] Failed to remove file: ${file}`, error);
            }
          }
        }
      }
      if (this.config.debug && (removed > 0 || errors > 0)) {
        console.log(`[TempFileManager] Cleanup complete: removed ${removed} files, ${errors} errors`);
      }
    } catch (error) {
      if (this.config.debug) {
        console.error("[TempFileManager] Cleanup process error:", error);
      }
    }
    return { removed, errors };
  }
  /**
   * Clean up all temporary files (regardless of time)
   *
   * Called when SDK is destroyed, immediately clean all imsg_temp_* files
   */
  async cleanupAll() {
    if (this.isDestroyed) {
      return { removed: 0, errors: 0 };
    }
    let removed = 0;
    let errors = 0;
    try {
      if (fs.existsSync(TEMP_DIR)) {
        const files = fs.readdirSync(TEMP_DIR);
        for (const file of files) {
          if (!file.startsWith(TEMP_FILE_PREFIX)) {
            continue;
          }
          const filePath = path.join(TEMP_DIR, file);
          try {
            fs.unlinkSync(filePath);
            removed++;
            if (this.config.debug) {
              console.log(`[TempFileManager] Removed file: ${file}`);
            }
          } catch (error) {
            errors++;
            if (this.config.debug) {
              console.error(`[TempFileManager] Failed to remove file: ${file}`, error);
            }
          }
        }
      }
      if (this.config.debug) {
        console.log(`[TempFileManager] Cleanup all files complete: removed ${removed}, ${errors} errors`);
      }
    } catch (error) {
      if (this.config.debug) {
        console.error("[TempFileManager] Cleanup all files error:", error);
      }
    }
    return { removed, errors };
  }
  /**
   * Stop cleanup task
   */
  stop() {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
    }
  }
  /**
   * Destroy manager (stop cleanup and clean all files)
   */
  async destroy() {
    if (this.isDestroyed) {
      return;
    }
    this.isDestroyed = true;
    this.stop();
    await this.cleanupAll();
    if (this.config.debug) {
      console.log("[TempFileManager] Destroyed");
    }
  }
  /**
   * Get statistics
   */
  getStats() {
    let currentFiles = 0;
    try {
      if (fs.existsSync(TEMP_DIR)) {
        const files = fs.readdirSync(TEMP_DIR);
        currentFiles = files.filter((f) => f.startsWith(TEMP_FILE_PREFIX)).length;
      }
    } catch {
    }
    return {
      currentFiles,
      isRunning: this.cleanupTimer !== null,
      config: { ...this.config }
    };
  }
};

// src/core/chain.ts
var MessageChain = class {
  constructor(message, sender) {
    this.message = message;
    this.sender = sender;
    if (typeof process !== "undefined" && process.env.NODE_ENV !== "production") {
      setTimeout(() => {
        if (!this.executed && this.actions.length > 0) {
          console.warn(
            "[MessageChain] Warning: Unexecuted message chain detected.",
            "You need to explicitly call .execute() method.\n",
            `Message ID: ${this.message.id}, Sender: ${this.message.sender}`
          );
        }
      }, 1e3);
    }
  }
  /** Whether to execute */
  shouldExecute = true;
  /** Actions */
  actions = [];
  /** Whether already executed */
  executed = false;
  /**
   * Conditional check
   */
  when(predicate) {
    if (this.shouldExecute) {
      this.shouldExecute = predicate(this.message);
    }
    return this;
  }
  /**
   * Match text pattern
   */
  matchText(pattern) {
    return this.when((m) => {
      if (!m.text) return false;
      return typeof pattern === "string" ? m.text.includes(pattern) : pattern.test(m.text);
    });
  }
  /**
   * Only process unread messages
   */
  ifUnread() {
    return this.when((m) => !m.isRead);
  }
  /**
   * Only process messages from others
   */
  ifFromOthers() {
    return this.when((m) => !m.isFromMe);
  }
  /**
   * Only process my own messages
   */
  ifFromMe() {
    return this.when((m) => m.isFromMe);
  }
  /**
   * Only process group chat messages
   */
  ifGroupChat() {
    return this.when((m) => m.isGroupChat);
  }
  /**
   * Reply with text
   */
  replyText(text) {
    if (this.shouldExecute) {
      this.actions.push(async () => {
        const replyText = typeof text === "function" ? text(this.message) : text;
        await this.sender.text(this.message.sender, replyText);
      });
    }
    return this;
  }
  /**
   * Reply with image
   */
  replyImage(images) {
    if (this.shouldExecute) {
      this.actions.push(async () => {
        const imagePaths = typeof images === "function" ? images(this.message) : images;
        const paths = Array.isArray(imagePaths) ? imagePaths : [imagePaths];
        await this.sender.textWithImages(this.message.sender, "", paths);
      });
    }
    return this;
  }
  /**
   * Execute custom operation
   */
  do(handler) {
    if (this.shouldExecute) {
      this.actions.push(async () => {
        await Promise.resolve(handler(this.message));
      });
    }
    return this;
  }
  /**
   * Execute all operations (explicit call)
   *
   * This is the only method that actually performs operations
   *
   * @throws If an error occurs during execution
   */
  async execute() {
    this.executed = true;
    if (!this.shouldExecute || this.actions.length === 0) {
      return;
    }
    for (const action of this.actions) {
      await action();
    }
  }
};
var str = (v, fallback = "") => v == null ? fallback : String(v);
var num = (v, fallback = 0) => typeof v === "number" ? v : fallback;
var bool = (v) => Boolean(v);
var Database;
async function initDatabase() {
  if (Database) return;
  if (typeof Bun !== "undefined") {
    const bunSqlite = await import('bun:sqlite');
    Database = bunSqlite.Database;
  } else {
    try {
      const BetterSqlite3 = await import('better-sqlite3');
      Database = BetterSqlite3.default || BetterSqlite3;
    } catch (error) {
      throw DatabaseError(
        "better-sqlite3 is required for Node.js runtime. Install it with: npm install better-sqlite3"
      );
    }
  }
}
var IMessageDatabase = class {
  /** SQLite database instance */
  db;
  /** macOS epoch time (timestamp of 2001-01-01) */
  MAC_EPOCH = (/* @__PURE__ */ new Date("2001-01-01T00:00:00Z")).getTime();
  /** Initialization promise */
  initPromise;
  /**
   * Open iMessage database
   * @param path Database file path
   * @throws DatabaseError When database fails to open
   */
  constructor(path) {
    this.initPromise = this.init(path);
  }
  /**
   * Initialize database (async)
   */
  async init(path) {
    try {
      await initDatabase();
      this.db = new Database(path, { readonly: true });
    } catch (error) {
      throw DatabaseError(
        `Failed to open database at ${path}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  /**
   * Ensure database is initialized before any operation
   */
  async ensureInit() {
    await this.initPromise;
  }
  /**
   * Query messages (with multiple filter options)
   *
   * @param filter Filter conditions (optional)
   * @returns Message query result (includes message list and statistics)
   * @throws DatabaseError When query fails
   *
   * @example Query all unread messages
   * ```ts
   * const result = await db.getMessages({ unreadOnly: true })
   * ```
   *
   * @example Query messages from specific sender
   * ```ts
   * const result = await db.getMessages({
   *   sender: '+1234567890',
   *   limit: 20
   * })
   * ```
   *
   * @example Query recent messages with attachments
   * ```ts
   * const result = await db.getMessages({
   *   hasAttachments: true,
   *   since: new Date('2024-01-01'),
   *   limit: 10
   * })
   * ```
   */
  async getMessages(filter = {}) {
    await this.ensureInit();
    const { unreadOnly, excludeOwnMessages = true, sender, chatId, service, hasAttachments, since, limit } = filter;
    let query = `
        SELECT 
            message.ROWID as id,
            message.guid,
            message.text,
            message.date,
            message.is_read,
            message.is_from_me,
            message.service,
            handle.id as sender,
            handle.ROWID as sender_rowid,
            chat.chat_identifier as chat_id,
            chat.display_name as chat_name,
            chat.ROWID as chat_rowid,
            (SELECT COUNT(*) FROM chat_handle_join WHERE chat_handle_join.chat_id = chat.ROWID) > 1 as is_group_chat
        FROM message
        LEFT JOIN handle ON message.handle_id = handle.ROWID
        LEFT JOIN chat_message_join ON message.ROWID = chat_message_join.message_id
        LEFT JOIN chat ON chat_message_join.chat_id = chat.ROWID
        WHERE 1=1
        `;
    const params = [];
    if (unreadOnly) {
      query += " AND message.is_read = 0";
    }
    if (excludeOwnMessages) {
      query += " AND message.is_from_me = 0";
    }
    if (sender) {
      query += " AND handle.id = ?";
      params.push(sender);
    }
    if (chatId) {
      query += " AND chat.chat_identifier = ?";
      params.push(chatId);
    }
    if (service) {
      query += " AND message.service = ?";
      params.push(service);
    }
    if (hasAttachments) {
      query += `
            AND EXISTS (
                SELECT 1 FROM message_attachment_join 
                WHERE message_attachment_join.message_id = message.ROWID
            )
            `;
    }
    if (since) {
      const macTimestampNs = (since.getTime() - this.MAC_EPOCH) * 1e6;
      query += " AND message.date >= ?";
      params.push(macTimestampNs);
    }
    query += " ORDER BY message.date DESC";
    if (limit) {
      query += " LIMIT ?";
      params.push(limit);
    }
    try {
      const rows = this.db.prepare(query).all(...params);
      const messages = await Promise.all(rows.map((row) => this.rowToMessage(row)));
      return {
        messages,
        total: messages.length,
        unreadCount: messages.filter((m) => !m.isRead).length
      };
    } catch (error) {
      throw DatabaseError(`Failed to query messages: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get unread messages grouped by sender
   *
   * @returns Map where key is sender identifier and value is array of messages from that sender
   *
   * @example
   * ```ts
   * const grouped = await db.getUnreadMessages()
   * for (const [sender, messages] of grouped) {
   *   console.log(`${sender}: ${messages.length} unread messages`)
   * }
   * ```
   */
  async getUnreadMessages() {
    const { messages } = await this.getMessages({ unreadOnly: true });
    const grouped = /* @__PURE__ */ new Map();
    for (const msg of messages) {
      const existing = grouped.get(msg.sender);
      if (existing) {
        existing.push(msg);
      } else {
        grouped.set(msg.sender, [msg]);
      }
    }
    return grouped;
  }
  /**
   * Get all attachments for specified message
   * @param messageId Message ID
   * @returns Array of attachments, returns empty array if no attachments
   */
  async getAttachments(messageId) {
    await this.ensureInit();
    const query = `
        SELECT 
            attachment.ROWID as id,
            attachment.filename,
            attachment.mime_type,
            attachment.total_bytes as size,
            attachment.created_date as created_date
        FROM attachment
        INNER JOIN message_attachment_join ON attachment.ROWID = message_attachment_join.attachment_id
        WHERE message_attachment_join.message_id = ?
        `;
    try {
      const rows = this.db.prepare(query).all(messageId);
      return rows.map((row) => {
        const rawPath = str(row.filename);
        const mimeType = str(row.mime_type, "application/octet-stream");
        let fullPath;
        if (rawPath.startsWith("~")) {
          fullPath = rawPath.replace(/^~/, os.homedir());
        } else if (rawPath && !rawPath.startsWith("/")) {
          fullPath = path.join(os.homedir(), "Library/Messages/Attachments", rawPath);
        } else {
          fullPath = rawPath;
        }
        return {
          id: str(row.id),
          filename: rawPath.split("/").pop() || "unknown",
          mimeType,
          path: fullPath,
          size: num(row.size, 0),
          isImage: mimeType.startsWith("image/"),
          createdAt: this.convertMacTimestamp(row.created_date)
        };
      });
    } catch {
      return [];
    }
  }
  /**
   * Convert database query result to Message object
   * @param row Raw row data from database query
   * @returns Formatted Message object
   */
  async rowToMessage(row) {
    return {
      id: str(row.id),
      guid: str(row.guid),
      text: row.text ? str(row.text) : null,
      sender: str(row.sender, "Unknown"),
      senderName: null,
      chatId: str(row.chat_id),
      isGroupChat: bool(row.is_group_chat),
      service: this.mapService(row.service),
      isRead: bool(row.is_read),
      isFromMe: bool(row.is_from_me),
      attachments: await this.getAttachments(str(row.id)),
      date: this.convertMacTimestamp(row.date)
    };
  }
  /**
   * Map service type string from database
   * @param service Service identifier from database
   * @returns Standardized service type
   */
  mapService(service) {
    if (!service || typeof service !== "string") return "iMessage";
    const lower = service.toLowerCase();
    if (lower.includes("sms")) return "SMS";
    if (lower.includes("rcs")) return "RCS";
    return "iMessage";
  }
  /**
   * Convert macOS timestamp to JavaScript Date object
   *
   * macOS epoch starts at 2001-01-01, unit is nanoseconds
   * @param timestamp macOS timestamp
   * @returns JavaScript Date object
   */
  convertMacTimestamp(timestamp) {
    if (!timestamp || typeof timestamp !== "number") return /* @__PURE__ */ new Date();
    return new Date(this.MAC_EPOCH + timestamp / 1e6);
  }
  /**
   * Close database connection
   */
  async close() {
    await this.ensureInit();
    this.db.close();
  }
};
var execAsync = util.promisify(child_process.exec);
var DEFAULT_SCRIPT_TIMEOUT = 3e4;
var execAppleScript = async (script, debug = false, timeoutMs = DEFAULT_SCRIPT_TIMEOUT) => {
  if (debug) {
    console.log("[AppleScript] Executing script:\n", script);
  }
  try {
    const escapedScript = script.replace(/'/g, "'\\''");
    const { stdout, stderr } = await execAsync(`osascript -e '${escapedScript}'`, {
      timeout: timeoutMs,
      encoding: "utf-8"
    });
    if (stderr && debug) {
      console.warn("[AppleScript] Warning:", stderr);
    }
    if (debug) {
      console.log("[AppleScript] Success:", stdout || "(no output)");
    }
    return stdout.trim();
  } catch (error) {
    const errorMsg = error.message || String(error);
    if (error.killed || errorMsg.includes("timeout")) {
      const message = [
        `AppleScript execution timeout (${timeoutMs}ms)`,
        "may be slow network or large file"
      ].join(" - ");
      throw new Error(message);
    }
    if (errorMsg.includes("Can't get buddy")) {
      throw new Error("Recipient not found or not added to iMessage contacts");
    }
    if (errorMsg.includes("Can't send")) {
      const reasons = [
        "1) Is Messages signed in to iMessage",
        "2) Is recipient correct",
        "3) Network connection"
      ].join(", ");
      throw new Error(`Send failed - please check: ${reasons}`);
    }
    if (debug) {
      console.error("[AppleScript] Error details:", error);
    }
    throw new Error(`AppleScript execution failed: ${errorMsg}`);
  }
};
var checkMessagesApp = async () => {
  try {
    await execAsync("pgrep -x Messages", {
      timeout: DEFAULT_SCRIPT_TIMEOUT
    });
    return true;
  } catch {
    return false;
  }
};
var checkIMessageStatus = async (debug = false) => {
  try {
    const script = `
tell application "Messages"
    try
        set accountList to every account
        if (count of accountList) is 0 then
            return "no_accounts"
        end if
        
        set hasActiveAccount to false
        repeat with acct in accountList
            if enabled of acct is true then
                set hasActiveAccount to true
                exit repeat
            end if
        end repeat
        
        if hasActiveAccount then
            return "active"
        else
            return "inactive"
        end if
    on error
        return "error"
    end try
end tell
`;
    const escapedScript = script.replace(/'/g, "'\\''");
    const { stdout } = await execAsync(`osascript -e '${escapedScript}'`, {
      timeout: 5e3
    });
    const result = stdout.trim();
    if (debug) {
      console.log("[iMessage Status Check]", result);
    }
    return result === "active";
  } catch (error) {
    if (debug) {
      console.warn("[iMessage Status Check Failed]", error);
    }
    return true;
  }
};
var escapeAppleScriptString = (str2) => {
  const escapeMap = {
    "\\": "\\\\",
    // Backslash
    '"': '\\"',
    // Double quote
    "\n": "\\n",
    // Newline
    "\r": "\\r",
    // Carriage return
    "	": "\\t"
    // Tab
  };
  return str2.replace(/[\\\n\r\t"]/g, (char) => escapeMap[char] || char);
};
var generateSendTextScript = (recipient, text) => {
  const escapedText = escapeAppleScriptString(text);
  return `
tell application "Messages"
    set targetBuddy to buddy "${recipient}"
    send "${escapedText}" to targetBuddy
end tell
`.trim();
};
function needsSandboxBypass(filePath) {
  return !filePath.match(/(Pictures|Downloads|Documents)/);
}
function generateSandboxBypassScript(filePath, recipient) {
  const fileName = filePath.split("/").pop();
  const tempFileName = `imsg_temp_${Date.now()}_${fileName}`;
  return `
    -- Bypass sandbox: copy to Pictures directory
    set picturesFolder to POSIX path of (path to pictures folder)
    set targetPath to picturesFolder & "${tempFileName}"
    do shell script "cp " & quoted form of "${filePath}" & " " & quoted form of targetPath
    
    -- Create file reference and send
    set theFile to (POSIX file targetPath) as alias
    set targetBuddy to buddy "${recipient}"
    send theFile to targetBuddy
    `.trim();
}
function generateDirectSendScript(filePath, recipient) {
  return `
    set targetBuddy to buddy "${recipient}"
    send POSIX file "${filePath}" to targetBuddy
    `.trim();
}
var generateSendAttachmentScript = (recipient, filePath, debug = false) => {
  const needsBypass = needsSandboxBypass(filePath);
  if (needsBypass && debug) {
    console.log("[AppleScript] Non-sandbox directory detected, will temporarily copy to ~/Pictures");
  }
  const sendScript = needsBypass ? generateSandboxBypassScript(filePath, recipient) : generateDirectSendScript(filePath, recipient);
  return {
    script: `
tell application "Messages"
${sendScript}
end tell
        `.trim()
  };
};
var generateSendWithAttachmentScript = (recipient, text, filePath) => {
  const escapedText = escapeAppleScriptString(text);
  const needsBypass = needsSandboxBypass(filePath);
  const attachmentScript = needsBypass ? generateSandboxBypassScript(filePath, recipient) : generateDirectSendScript(filePath, recipient);
  return {
    script: `
tell application "Messages"
    set targetBuddy to buddy "${recipient}"
    
    -- Send text
    send "${escapedText}" to targetBuddy
    
    -- Send attachment
${attachmentScript}
end tell
        `.trim()
  };
};

// src/utils/common.ts
var delay = (ms) => {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
};
function validateMessageContent(text, attachments) {
  const hasText = Boolean(text && text.trim().length > 0);
  const hasAttachments = Boolean(attachments && attachments.length > 0);
  if (!hasText && !hasAttachments) {
    throw new Error("Message must contain text or attachments");
  }
  return { hasText, hasAttachments };
}
var execAsync2 = util.promisify(child_process.exec);
var TEMP_DIR2 = path.join(os.homedir(), "Pictures");
var convertImageToJPEG = async (inputPath, outputPath) => {
  const output = outputPath || path.join(TEMP_DIR2, `imsg_temp_${Date.now()}.jpg`);
  try {
    const cmd = `sips -s format jpeg "${inputPath}" --out "${output}"`;
    await execAsync2(cmd, { timeout: 1e4 });
    if (!fs.existsSync(output)) {
      throw new Error("Converted file does not exist");
    }
    return output;
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    throw SendError(`Image format conversion failed: ${msg}`);
  }
};
var downloadImage = async (url, options = {}) => {
  const { timeout = 15e3, maxRetries = 2, retryDelay = 1e3, debug = false } = options;
  let lastError = null;
  if (debug) {
    console.log(`[Download] ${url.length > 60 ? `${url.slice(0, 60)}...` : url}`);
  }
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      if (attempt > 0) {
        await delay(retryDelay * 2 ** (attempt - 1));
      }
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      const response = await fetch(url, {
        signal: controller.signal,
        headers: {
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
          Accept: "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8",
          "Accept-Encoding": "gzip, deflate, br"
        }
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} ${response.statusText}`);
      }
      const contentType = response.headers.get("content-type")?.toLowerCase() || "";
      const buffer = Buffer.from(await response.arrayBuffer());
      if (contentType.includes("avif") || contentType.includes("webp")) {
        const ext2 = contentType.includes("avif") ? ".avif" : ".webp";
        const tempPath = path.join(TEMP_DIR2, `imsg_temp_${Date.now()}${ext2}`);
        fs.writeFileSync(tempPath, buffer);
        const converted = await convertImageToJPEG(tempPath);
        if (debug) {
          console.log(`[Download] Converted ${ext2} -> .jpg`);
        }
        return converted;
      }
      const extMap = {
        png: ".png",
        gif: ".gif",
        svg: ".svg",
        bmp: ".bmp"
      };
      const ext = Object.entries(extMap).find(([key]) => contentType.includes(key))?.[1] || ".jpg";
      const path$1 = path.join(TEMP_DIR2, `imsg_temp_${Date.now()}${ext}`);
      fs.writeFileSync(path$1, buffer);
      return path$1;
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      if (lastError.name === "AbortError") {
        lastError = new Error(`Request timeout (${timeout}ms)`);
      }
      if (attempt === maxRetries) {
        throw SendError(`Download failed (${maxRetries + 1} attempts): ${lastError.message}
URL: ${url}`);
      }
      if (debug && attempt > 0) {
        console.warn(`[Download] Retry ${attempt + 1}/${maxRetries + 1}: ${lastError.message}`);
      }
    }
  }
  throw SendError(`Download failed: ${lastError?.message}`);
};
var convertToCompatibleFormat = async (filePath) => {
  const ext = filePath.split(".").pop()?.toLowerCase();
  if (!ext || !["avif", "webp"].includes(ext)) {
    return { path: filePath, converted: false };
  }
  const fileName = filePath.split("/").pop().replace(/\.(avif|webp)$/i, ".jpg");
  const isOurTemp = fileName.startsWith("imsg_temp_");
  const output = isOurTemp ? path.join(TEMP_DIR2, fileName) : path.join(TEMP_DIR2, `imsg_temp_${Date.now()}_${fileName}`);
  const converted = await convertImageToJPEG(filePath, output);
  return { path: converted, converted: true };
};

// src/utils/semaphore.ts
var Semaphore = class {
  constructor(limit) {
    this.limit = limit;
    if (limit <= 0) {
      throw new Error("Concurrency limit must be greater than 0");
    }
  }
  running = 0;
  waiting = [];
  /**
   * Acquire semaphore
   *
   * @returns Release function
   */
  async acquire() {
    while (this.running >= this.limit) {
      await new Promise((resolve2) => this.waiting.push(resolve2));
    }
    this.running++;
    return () => {
      this.running--;
      const next = this.waiting.shift();
      if (next) {
        next();
      }
    };
  }
  /**
   * Run async function (auto-manage semaphore)
   *
   * @param fn Async function
   * @returns Function execution result
   */
  async run(fn) {
    const release = await this.acquire();
    try {
      return await fn();
    } finally {
      release();
    }
  }
};

// src/core/sender.ts
var MessageSender = class {
  /** Debug mode */
  debug;
  /** Maximum retry attempts */
  maxRetries;
  /** Retry delay */
  retryDelay;
  /** Concurrency limiter */
  semaphore;
  /** AppleScript timeout */
  scriptTimeout;
  constructor(debug = false, retryConfig, maxConcurrent = 5, scriptTimeout = 3e4) {
    this.debug = debug;
    this.maxRetries = retryConfig?.max ?? 2;
    this.retryDelay = retryConfig?.delay ?? 1500;
    this.semaphore = maxConcurrent > 0 ? new Semaphore(maxConcurrent) : null;
    this.scriptTimeout = scriptTimeout;
  }
  /**
   * Execute script with retry
   *
   * @param script AppleScript code
   * @param description Operation description
   * @returns Execution result
   */
  async executeWithRetry(script, description) {
    let lastError = null;
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        if (attempt > 1) {
          await delay(this.retryDelay);
        }
        await execAppleScript(script, this.debug, this.scriptTimeout);
        return;
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
      }
    }
    const errorMsg = lastError?.message || "unknown error";
    throw SendError(`${description} failed (retried ${this.maxRetries} times): ${errorMsg}`);
  }
  /**
   * Resolve attachment path
   * - Download network images (HTTP URL) → ~/Pictures/imsg_temp_*
   * - Validate local file path
   * - Auto-convert incompatible formats (AVIF/WebP -> JPEG) → ~/Pictures/imsg_temp_*
   *
   * Note: All temporary files are automatically named imsg_temp_* and stored in ~/Pictures
   *       TempFileManager will automatically scan and clean up these files, no manual tracking needed
   *
   * @param path Attachment path (local path or HTTP URL)
   * @returns Local path
   */
  async resolveAttachment(path$1) {
    if (isURL(path$1)) {
      return await downloadImage(path$1, { debug: this.debug });
    }
    const localPath = path.resolve(path$1);
    if (!fs.existsSync(localPath)) {
      throw SendError(`File not found: ${path$1}`);
    }
    const converted = await convertToCompatibleFormat(localPath);
    if (converted.converted && this.debug) {
      const originalFile = localPath.split("/").pop();
      const convertedFile = converted.path.split("/").pop();
      console.log(`[Format Conversion] ${originalFile} -> ${convertedFile}`);
    }
    return converted.path;
  }
  /**
   * Send message
   */
  async send(options) {
    if (this.semaphore) {
      return await this.semaphore.run(() => this.sendInternal(options));
    }
    return await this.sendInternal(options);
  }
  /**
   * Check abort signal
   */
  checkAbortSignal(signal) {
    if (signal?.aborted) {
      throw SendError("Send cancelled");
    }
  }
  /**
   * Check Messages environment
   */
  async checkMessagesEnvironment() {
    const isAvailable = await checkMessagesApp();
    if (!isAvailable) {
      throw SendError("Messages app is not running");
    }
    if (this.debug) {
      const iMessageActive = await checkIMessageStatus(this.debug);
      if (!iMessageActive) {
        console.warn(
          '[Warning] iMessage account may not be logged in or activated, messages may show "Not Delivered"'
        );
        console.warn("[Suggestion] Open Messages app > Settings > iMessage, ensure Apple ID is logged in");
      }
    }
  }
  /**
   * Prepare all attachments (download, convert)
   */
  async prepareAttachments(attachments) {
    if (attachments.length === 0) {
      return [];
    }
    if (this.debug) {
      console.log(`[Processing Attachments] Total ${attachments.length} attachments`);
    }
    const resolvedPaths = [];
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      if (this.debug) {
        const attachmentPreview = attachment.length > 80 ? `${attachment.slice(0, 80)}...` : attachment;
        console.log(`[Processing Attachments] ${i + 1}/${attachments.length}: ${attachmentPreview}`);
      }
      const resolved = await this.resolveAttachment(attachment);
      resolvedPaths.push(resolved);
    }
    return resolvedPaths;
  }
  /**
   * Execute send strategy
   */
  async executeSendStrategy(recipient, text, hasText, resolvedPaths) {
    if (hasText && resolvedPaths.length > 0) {
      const firstAttachment = resolvedPaths[0];
      const { script } = generateSendWithAttachmentScript(recipient, text, firstAttachment);
      await this.executeWithRetry(script, `Send text and attachment to ${recipient}`);
      for (let i = 1; i < resolvedPaths.length; i++) {
        const { script: attachScript } = generateSendAttachmentScript(recipient, resolvedPaths[i], this.debug);
        await this.executeWithRetry(attachScript, `Send attachment ${i + 1}/${resolvedPaths.length}`);
      }
    } else if (hasText) {
      const script = generateSendTextScript(recipient, text);
      await this.executeWithRetry(script, `Send text to ${recipient}`);
    } else {
      for (let i = 0; i < resolvedPaths.length; i++) {
        const { script } = generateSendAttachmentScript(recipient, resolvedPaths[i], this.debug);
        const description = `Send attachment ${i + 1}/${resolvedPaths.length} to ${recipient}`;
        await this.executeWithRetry(script, description);
      }
    }
  }
  /**
   * Send message (internal implementation)
   */
  async sendInternal(options) {
    const { to, text, attachments = [], signal } = options;
    const recipient = String(to);
    this.checkAbortSignal(signal);
    let hasText;
    try {
      const validation = validateMessageContent(text, attachments);
      hasText = validation.hasText;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      throw SendError(errorMsg);
    }
    try {
      this.checkAbortSignal(signal);
      await this.checkMessagesEnvironment();
      const resolvedPaths = await this.prepareAttachments(attachments);
      await this.executeSendStrategy(recipient, text, hasText, resolvedPaths);
      return { sentAt: /* @__PURE__ */ new Date() };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      const contextInfo = `[Recipient: ${recipient}] [Text: ${hasText ? "yes" : "no"}] [Attachments: ${attachments.length}]`;
      if (error instanceof IMessageError) {
        throw SendError(`${errorMsg} ${contextInfo}`);
      }
      throw SendError(`Send failed ${contextInfo}: ${errorMsg}`);
    }
  }
  async text(to, text) {
    return this.send({ to, text });
  }
  async image(to, imagePath) {
    return this.send({ to, attachments: [imagePath] });
  }
  async textWithImages(to, text, imagePaths) {
    return this.send({
      to,
      text,
      attachments: imagePaths
    });
  }
};

// src/core/watcher.ts
var MessageWatcher = class {
  constructor(database, pollInterval, unreadOnly, excludeOwnMessages, webhookConfig, events = {}, pluginManager, debug = false) {
    this.database = database;
    this.pollInterval = pollInterval;
    this.unreadOnly = unreadOnly;
    this.excludeOwnMessages = excludeOwnMessages;
    this.webhookConfig = webhookConfig;
    this.events = events;
    this.pluginManager = pluginManager;
    this.debug = debug;
    this.lastCheckTime = /* @__PURE__ */ new Date();
  }
  /** Whether currently running */
  isRunning = false;
  /** Polling timer ID */
  intervalId = null;
  /** Whether currently checking */
  isChecking = false;
  /** Last check time (for incremental queries) */
  lastCheckTime;
  /** Set of processed message IDs (simple deduplication) */
  seenMessageIds = /* @__PURE__ */ new Map();
  /**
   * Start watching for new messages
   */
  async start() {
    if (this.isRunning) return;
    this.isRunning = true;
    if (this.debug) {
      console.log(`[Watcher] Started (poll interval: ${this.pollInterval}ms)`);
    }
    try {
      await this.check();
    } catch (error) {
      this.isRunning = false;
      throw error;
    }
    this.intervalId = setInterval(() => {
      this.check().catch((error) => {
        this.handleError(error);
      });
    }, this.pollInterval);
  }
  /**
   * Stop watching
   */
  stop() {
    if (!this.isRunning) return;
    this.isRunning = false;
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    if (this.debug) {
      console.log("[Watcher] Stopped");
    }
  }
  /**
   * Check for new messages
   */
  async check() {
    if (this.isChecking) return;
    this.isChecking = true;
    try {
      const overlapMs = Math.min(1e3, this.pollInterval);
      const checkStart = /* @__PURE__ */ new Date();
      const since = new Date(this.lastCheckTime.getTime() - overlapMs);
      const { messages } = await this.database.getMessages({
        since
      });
      this.lastCheckTime = checkStart;
      let newMessages = messages.filter((msg) => !this.seenMessageIds.has(msg.id));
      if (this.unreadOnly) {
        newMessages = newMessages.filter((msg) => !msg.isRead);
      }
      if (this.excludeOwnMessages) {
        newMessages = newMessages.filter((msg) => !msg.isFromMe);
      }
      const now = Date.now();
      for (const msg of newMessages) {
        this.seenMessageIds.set(msg.id, now);
      }
      await Promise.all(
        newMessages.map((msg) => this.handleNewMessage(msg).catch((err) => this.handleError(err)))
      );
      if (this.seenMessageIds.size > 1e4) {
        const hourAgo = now - 36e5;
        for (const [id, timestamp] of this.seenMessageIds.entries()) {
          if (timestamp < hourAgo) {
            this.seenMessageIds.delete(id);
          }
        }
      }
    } catch (error) {
      this.handleError(error);
    } finally {
      this.isChecking = false;
    }
  }
  /**
   * Handle new message
   * Triggers in sequence: Plugin hooks -> Event callback -> Webhook notification
   * @param message New message object
   */
  async handleNewMessage(message) {
    try {
      await this.pluginManager?.callHookForAll("onNewMessage", message);
      if (message.isGroupChat) {
        await this.events.onGroupMessage?.(message);
      } else {
        await this.events.onNewMessage?.(message);
      }
      if (this.webhookConfig) await this.sendWebhook(message);
    } catch (error) {
      this.handleError(error);
    }
  }
  /**
   * Send webhook notification
   * POST message data to configured webhook URL
   * @param message Message to notify
   */
  async sendWebhook(message) {
    if (!this.webhookConfig) return;
    try {
      const response = await fetch(this.webhookConfig.url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...this.webhookConfig.headers
        },
        body: JSON.stringify({
          event: "new_message",
          message: {
            id: message.id,
            text: message.text,
            sender: message.sender,
            senderName: message.senderName,
            isRead: message.isRead,
            service: message.service,
            hasAttachments: message.attachments.length > 0,
            attachments: message.attachments.map((a) => ({
              filename: a.filename,
              mimeType: a.mimeType,
              size: a.size,
              isImage: a.isImage
            })),
            date: message.date.toISOString()
          },
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }),
        signal: AbortSignal.timeout(this.webhookConfig.timeout || 5e3)
      });
      if (!response.ok) {
        throw WebhookError(`Webhook failed with status ${response.status}`);
      }
    } catch (error) {
      throw WebhookError(`Failed to send webhook: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Unified error handling
   * Output error to console and trigger error callback
   * @param error Error object of any type
   */
  handleError(error) {
    const err = error instanceof Error ? error : new Error(String(error));
    if (this.debug) {
      console.error("[Watcher] Error:", err);
    }
    this.events.onError?.(err);
  }
};

// src/core/sdk.ts
var IMessageSDK = class {
  /** Configuration */
  config;
  /** Database */
  database;
  /** Temporary file manager */
  tempFileManager;
  /** Message sender */
  sender;
  /** Plugin manager */
  pluginManager;
  /** Message watcher */
  watcher = null;
  /** Whether destroyed */
  destroyed = false;
  constructor(config = {}, dependencies) {
    requireMacOS();
    this.config = this.resolveConfig(config);
    this.database = dependencies?.database ?? new IMessageDatabase(this.config.databasePath);
    this.tempFileManager = new TempFileManager({
      maxAge: this.config.tempFile?.maxAge,
      cleanupInterval: this.config.tempFile?.cleanupInterval,
      debug: this.config.debug
    });
    this.tempFileManager.start();
    this.sender = dependencies?.sender ?? new MessageSender(
      this.config.debug,
      this.config.retry,
      this.config.maxConcurrent,
      this.config.scriptTimeout
    );
    this.pluginManager = dependencies?.pluginManager ?? new PluginManager();
    if (config.plugins) {
      for (const plugin of config.plugins) {
        this.pluginManager.use(plugin);
      }
    }
    if (this.config.debug) {
      console.log("[SDK] Initialization complete");
    }
  }
  async ensurePluginsReady() {
    if (!this.pluginManager.initialized) {
      await this.pluginManager.init();
    }
  }
  resolveConfig(config) {
    const clamp = (v, min, max, def) => {
      const val = v ?? def;
      if (val < min || val > max) {
        throw new Error(`Value must be between ${min} and ${max}`);
      }
      return val;
    };
    return {
      databasePath: config.databasePath ?? getDefaultDatabasePath(),
      webhook: config.webhook ?? null,
      watcher: {
        pollInterval: clamp(config.watcher?.pollInterval, 100, 6e4, 2e3),
        unreadOnly: config.watcher?.unreadOnly ?? false,
        excludeOwnMessages: config.watcher?.excludeOwnMessages ?? true
      },
      retry: {
        max: clamp(config.retry?.max, 0, 10, 2),
        delay: clamp(config.retry?.delay, 0, 1e4, 1500)
      },
      tempFile: {
        maxAge: clamp(config.tempFile?.maxAge, 6e4, 36e5, 6e5),
        // 1 minute ~ 1 hour, default 10 minutes
        cleanupInterval: clamp(config.tempFile?.cleanupInterval, 6e4, 18e5, 3e5)
        // 1 minute ~ 30 minutes, default 5 minutes
      },
      scriptTimeout: clamp(config.scriptTimeout, 5e3, 12e4, 3e4),
      // 5 seconds ~ 2 minutes, default 30 seconds
      maxConcurrent: clamp(config.maxConcurrent, 0, 50, 5),
      debug: config.debug ?? false
    };
  }
  /** Generic wrapper for sending messages */
  async sendWithHooks(to, sendFn, content) {
    if (this.destroyed) throw new Error("SDK is destroyed");
    await this.ensurePluginsReady();
    const recipient = typeof to === "string" ? asRecipient(to) : to;
    await this.pluginManager.callHookForAll("onBeforeSend", recipient, content);
    const result = await sendFn(recipient);
    await this.pluginManager.callHookForAll("onAfterSend", recipient, result);
    return result;
  }
  /**
   * Register plugin
   */
  use(plugin) {
    if (this.destroyed) throw new Error("SDK is destroyed");
    this.pluginManager.use(plugin);
    return this;
  }
  /**
   * Get plugin manager
   * @returns PluginManager instance
   */
  get plugins() {
    return this.pluginManager;
  }
  /**
   * Query messages
   */
  async getMessages(filter) {
    if (this.destroyed) throw new Error("SDK is destroyed");
    await this.ensurePluginsReady();
    await this.pluginManager.callHookForAll("onBeforeQuery", filter);
    const result = await this.database.getMessages(filter);
    await this.pluginManager.callHookForAll("onAfterQuery", result.messages);
    return result;
  }
  /**
   * Get unread messages (grouped by sender)
   */
  async getUnreadMessages() {
    if (this.destroyed) throw new Error("SDK is destroyed");
    const map = await this.database.getUnreadMessages();
    return Array.from(map.entries()).map(([sender, messages]) => ({
      sender,
      messages
    }));
  }
  /**
   * Send message
   *
   * @example
   * ```ts
   * await sdk.send(phone, 'Hello')
   * await sdk.send(phone, { images: ['/img.jpg'] })
   * await sdk.send(phone, { text: 'Hi', images: ['/img.jpg'] })
   * await sdk.send(phone, { files: ['/document.pdf', '/contact.vcf'] })
   * await sdk.send(phone, { text: 'Check this', files: ['/data.csv'] })
   * ```
   */
  async send(to, content) {
    const normalized = typeof content === "string" ? { text: content, attachments: [] } : {
      text: content.text,
      attachments: [...content.images || [], ...content.files || []]
    };
    return this.sendWithHooks(
      to,
      (r) => this.sender.send({
        to: r,
        text: normalized.text,
        attachments: normalized.attachments
      }),
      {
        text: normalized.text,
        attachments: normalized.attachments
      }
    );
  }
  /**
   * Send batch messages (concurrency controlled by sender's maxConcurrent config)
   *
   * @param messages Batch message list
   * @returns List of send results (including success and failure)
   *
   * @example
   * ```ts
   * const results = await sdk.sendBatch([
   *   { to: '+1234567890', content: 'Hello' },
   *   { to: '+0987654321', content: 'Hi' },
   * ])
   *
   * for (const result of results) {
   *   if (result.success) {
   *     console.log('Send success:', result.to)
   *   } else {
   *     console.error('Send failed:', result.to, result.error)
   *   }
   * }
   * ```
   */
  async sendBatch(messages) {
    if (this.destroyed) throw new Error("SDK is destroyed");
    const results = await Promise.allSettled(
      messages.map(async ({ to, content }) => ({
        to: String(to),
        result: await this.send(to, content)
      }))
    );
    return results.map((result, index) => {
      const to = String(messages[index].to);
      if (result.status === "fulfilled") {
        return {
          to,
          success: true,
          result: result.value.result
        };
      }
      return {
        to,
        success: false,
        error: result.reason instanceof Error ? result.reason : new Error(String(result.reason))
      };
    });
  }
  /**
   * Send file (convenience method)
   *
   * @example
   * ```ts
   * await sdk.sendFile('+1234567890', '/path/to/document.pdf')
   * await sdk.sendFile('+1234567890', '/path/to/contact.vcf', 'Here is the contact')
   * ```
   */
  async sendFile(to, filePath, text) {
    return this.send(to, { text, files: [filePath] });
  }
  /**
   * Send multiple files (convenience method)
   *
   * @example
   * ```ts
   * await sdk.sendFiles('+1234567890', ['/file1.pdf', '/file2.csv'])
   * await sdk.sendFiles('+1234567890', ['/data.xlsx'], 'Check these files')
   * ```
   */
  async sendFiles(to, filePaths, text) {
    return this.send(to, { text, files: filePaths });
  }
  // ==================== Message Chain Processing ====================
  /**
   * Create message processing chain
   */
  message(message) {
    if (this.destroyed) throw new Error("SDK is destroyed");
    return new MessageChain(message, this.sender);
  }
  /**
   * Start watching for new messages
   */
  async startWatching(events) {
    if (this.destroyed) throw new Error("SDK is destroyed");
    if (this.watcher) throw new Error("Watcher is already running");
    const watcher = new MessageWatcher(
      this.database,
      this.config.watcher.pollInterval,
      this.config.watcher.unreadOnly,
      this.config.watcher.excludeOwnMessages,
      this.config.webhook,
      events,
      this.pluginManager,
      this.config.debug
    );
    try {
      await watcher.start();
      this.watcher = watcher;
    } catch (error) {
      watcher.stop();
      throw error;
    }
  }
  /**
   * Stop watching for new messages
   */
  stopWatching() {
    this.watcher?.stop();
    this.watcher = null;
  }
  /**
   * Close SDK and release resources
   */
  async close() {
    if (this.destroyed) return;
    this.destroyed = true;
    const errors = [];
    try {
      this.watcher?.stop();
    } catch (error) {
      errors.push({
        component: "watcher",
        error: error instanceof Error ? error : new Error(String(error))
      });
    }
    this.watcher = null;
    try {
      await this.pluginManager.destroy();
    } catch (error) {
      errors.push({
        component: "pluginManager",
        error: error instanceof Error ? error : new Error(String(error))
      });
    }
    try {
      await this.tempFileManager.destroy();
    } catch (error) {
      errors.push({
        component: "tempFileManager",
        error: error instanceof Error ? error : new Error(String(error))
      });
    }
    try {
      this.database.close();
    } catch (error) {
      errors.push({
        component: "database",
        error: error instanceof Error ? error : new Error(String(error))
      });
    }
    if (errors.length > 0) {
      if (this.config.debug) {
        console.error("[SDK] Error occurred during shutdown:", errors);
      }
      if (typeof AggregateError !== "undefined") {
        throw new AggregateError(
          errors.map((e) => e.error),
          `SDK shutdown failed: ${errors.map((e) => e.component).join(", ")}`
        );
      }
      throw errors[0].error;
    }
  }
  /** Support using declaration (TypeScript 5.2+) */
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  /** Support using declaration (sync version) */
  [Symbol.dispose]() {
    this.close().catch(console.error);
  }
};

// src/plugins/logger.ts
var LEVELS = { debug: 0, info: 1, warn: 2, error: 3 };
var COLORS = {
  debug: "\x1B[36m",
  info: "\x1B[32m",
  warn: "\x1B[33m",
  error: "\x1B[31m"
};
var RESET = "\x1B[0m";
var loggerPlugin = (options = {}) => {
  const { level = "info", colored = true, timestamp = false, logSend = true, logNewMessage = false } = options;
  const log = (logLevel, message, data) => {
    if (LEVELS[logLevel] < LEVELS[level]) return;
    const time = timestamp ? (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US") : "";
    const tag = logLevel.toUpperCase().padEnd(5);
    const color = colored ? COLORS[logLevel] : "";
    const reset = colored ? RESET : "";
    const prefix = time ? `${time} ${color}[${tag}]${reset}` : `${color}[${tag}]${reset}`;
    const output = `${prefix} ${message}`;
    console.log(output);
  };
  return definePlugin({
    name: "logger",
    version: "1.0.0",
    description: "Logger plugin",
    onInit: () => {
      log("info", "SDK initialized");
    },
    onBeforeSend: (to, content) => {
      if (!logSend) return;
      const preview = content.text?.substring(0, 30) || "(no text)";
      const attachCount = content.attachments?.length || 0;
      const attachInfo = attachCount ? ` + ${attachCount} attachment(s)` : "";
      log("info", `[SEND] Sending to ${to}: ${preview}${attachInfo}`);
    },
    onAfterSend: (to) => {
      if (logSend) {
        log("info", `[OK] Sent successfully -> ${to}`);
      }
    },
    onNewMessage: (message) => {
      if (!logNewMessage) return;
      const preview = message.text?.substring(0, 40) || "(no text)";
      const attachCount = message.attachments.length;
      const attachInfo = attachCount ? ` [${attachCount}]` : "";
      log("info", `[MSG] New message from ${message.sender}: ${preview}${attachInfo}`);
    },
    onError: (error, context) => {
      const contextInfo = context || "Error";
      log("error", `[ERROR] ${contextInfo}: ${error.message}`);
    },
    onDestroy: () => {
      log("info", "[CLOSE] SDK destroyed");
    }
  });
};

exports.ConfigError = ConfigError;
exports.DatabaseError = DatabaseError;
exports.IMessageError = IMessageError;
exports.IMessageSDK = IMessageSDK;
exports.MessageChain = MessageChain;
exports.PlatformError = PlatformError;
exports.SendError = SendError;
exports.WebhookError = WebhookError;
exports.asRecipient = asRecipient;
exports.definePlugin = definePlugin;
exports.isMacOS = isMacOS;
exports.loggerPlugin = loggerPlugin;
exports.requireMacOS = requireMacOS;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map