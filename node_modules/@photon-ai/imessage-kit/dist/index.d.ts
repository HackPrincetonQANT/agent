/**
 * Message related types
 */
/**
 * Message service type
 *
 * - iMessage: Apple's iMessage service
 * - SMS: Traditional SMS service
 * - RCS: Rich Communication Services
 */
type ServiceType = 'iMessage' | 'SMS' | 'RCS';
/**
 * Message attachment information
 *
 * Contains file metadata and local path
 */
interface Attachment {
    /** Unique ID of the attachment in database */
    readonly id: string;
    /** Filename */
    readonly filename: string;
    /** MIME type (e.g. image/jpeg) */
    readonly mimeType: string;
    /** Full local path to the file */
    readonly path: string;
    /** File size in bytes */
    readonly size: number;
    /** Whether this is an image type */
    readonly isImage: boolean;
    /** Attachment creation time */
    readonly createdAt: Date;
}
/**
 * Message object
 *
 * Represents a complete iMessage/SMS message
 */
interface Message {
    /** Unique ID of the message in database */
    readonly id: string;
    /** Globally unique identifier for the message */
    readonly guid: string;
    /** Message text content (null for non-text messages) */
    readonly text: string | null;
    /** Sender identifier (phone number or email) */
    readonly sender: string;
    /** Sender display name (may be null) */
    readonly senderName: string | null;
    /** ID of the chat this message belongs to */
    readonly chatId: string;
    /** Whether this is a group chat message */
    readonly isGroupChat: boolean;
    /** Message service type */
    readonly service: ServiceType;
    /** Whether the message is read */
    readonly isRead: boolean;
    /** Whether the message is sent by me */
    readonly isFromMe: boolean;
    /** List of attachments (readonly array) */
    readonly attachments: readonly Attachment[];
    /** Message sent/received time */
    readonly date: Date;
}
/**
 * Message query filter
 *
 * All fields are optional, used to filter messages
 */
interface MessageFilter {
    /** Only query unread messages */
    readonly unreadOnly?: boolean;
    /** Exclude messages sent by current user (default: true) */
    readonly excludeOwnMessages?: boolean;
    /** Filter by sender */
    readonly sender?: string;
    /** Filter by chat ID */
    readonly chatId?: string;
    /** Filter by service type */
    readonly service?: ServiceType;
    /** Only query messages with attachments */
    readonly hasAttachments?: boolean;
    /** Only query messages after this time */
    readonly since?: Date;
    /** Limit number of results */
    readonly limit?: number;
}
/**
 * Message query result
 *
 * Contains message list and statistics
 */
interface MessageQueryResult {
    /** List of messages */
    readonly messages: readonly Message[];
    /** Total number of messages found */
    readonly total: number;
    /** Number of unread messages */
    readonly unreadCount: number;
}
/**
 * Send result
 *
 * Represents successful message sending result
 */
interface SendResult$1 {
    /** Message sent time */
    readonly sentAt: Date;
}

/**
 * Plugin System
 *
 * Plugins can listen to the following lifecycle hooks:
 * - SDK initialization and destruction
 * - Before and after message queries
 * - Before and after sending messages
 * - When new messages are received
 * - When errors occur
 */

/**
 * Plugin lifecycle hooks
 */
interface PluginHooks {
    /** Called when SDK initialization is complete */
    onInit?: () => void | Promise<void>;
    /** Called before querying messages (useful for logging) */
    onBeforeQuery?: (filter: unknown) => void | Promise<void>;
    /** Called after querying messages (useful for data processing) */
    onAfterQuery?: (messages: readonly Message[]) => void | Promise<void>;
    /** Called before sending a message (useful for validation, logging) */
    onBeforeSend?: (to: string, content: {
        text?: string;
        attachments?: string[];
    }) => void | Promise<void>;
    /** Called after sending a message (useful for logging results) */
    onAfterSend?: (to: string, result: SendResult$1) => void | Promise<void>;
    /** Called when a new message is received (triggered by listener) */
    onNewMessage?: (message: Message) => void | Promise<void>;
    /** Called when an error occurs (global error handling) */
    onError?: (error: Error, context?: string) => void | Promise<void>;
    /** Called when SDK is destroyed (cleanup resources) */
    onDestroy?: () => void | Promise<void>;
}
/**
 * Plugin metadata
 */
interface PluginMetadata {
    /** Unique plugin name */
    readonly name: string;
    /** Plugin version number (optional) */
    readonly version?: string;
    /** Plugin description (optional) */
    readonly description?: string;
}
/**
 * Complete plugin interface
 * Plugin = metadata + hook functions
 */
interface Plugin extends PluginMetadata, PluginHooks {
}
/**
 * Plugin manager
 */
declare class PluginManager {
    /** List of registered plugins */
    private plugins;
    /** Whether the plugin manager has been initialized */
    initialized: boolean;
    /**
     * Register a plugin
     * If the manager is already initialized, the plugin's onInit hook will be called immediately
     * @param plugin Plugin instance
     * @returns this - Supports method chaining
     */
    use(plugin: Plugin): this;
    /**
     * Initialize all plugins
     * Calls the onInit hook for all plugins
     */
    init(): Promise<void>;
    /**
     * Destroy all plugins
     * Calls the onDestroy hook for all plugins and clears the plugin list
     */
    destroy(): Promise<void>;
    /**
     * Call the specified hook for all plugins
     * @param hookName Hook name
     * @param args Hook arguments
     * @returns List of plugin errors (if any)
     */
    callHookForAll<K extends keyof PluginHooks>(hookName: K, ...args: Parameters<NonNullable<PluginHooks[K]>>): Promise<Array<{
        plugin: string;
        error: Error;
    }>>;
}
/**
 * Helper function to define a plugin
 */
declare const definePlugin: (plugin: Plugin) => Plugin;

/**
 * Utility types and helper functions
 */
/**
 * Recipient type
 *
 * Can be one of the following formats:
 * - Phone number
 * - Email address
 */
type Recipient = string;
/**
 * Validate recipient format
 *
 * Supported formats:
 * - Phone number: +1234567890, (123) 456-7890
 * - Email address: user@example.com
 *
 * @param value Recipient string (phone or email)
 * @returns Validated recipient
 * @throws TypeError when format is invalid
 */
declare const asRecipient: (value: string) => Recipient;
/**
 * Predicate function
 * Returns whether a condition is met
 */
type Predicate<T> = (value: T) => boolean;
/**
 * Mapper function
 * Transforms type T to type U
 */
type Mapper<T, U> = (value: T) => U;

/**
 * SDK configuration types
 */

/**
 * Webhook notification configuration
 *
 * Used to send HTTP notifications when new messages are received
 */
interface WebhookConfig {
    /** Webhook URL address */
    readonly url: string;
    /** Custom HTTP headers */
    readonly headers?: Record<string, string>;
    /** Request timeout in milliseconds (default: 5000) */
    readonly timeout?: number;
}
/**
 * Message watcher configuration
 *
 * Controls message polling behavior
 */
interface WatcherConfig {
    /** Poll interval in milliseconds (default: 2000) */
    readonly pollInterval?: number;
    /** Only watch unread messages (default: false) */
    readonly unreadOnly?: boolean;
    /** Exclude messages sent by current user (default: true) */
    readonly excludeOwnMessages?: boolean;
}
/**
 * Retry configuration
 *
 * Controls retry behavior when message sending fails
 */
interface RetryConfig {
    /** Maximum retry attempts (default: 2) */
    readonly max?: number;
    /** Base retry delay in milliseconds (default: 1500) */
    readonly delay?: number;
}
/**
 * Temporary file configuration
 *
 * Controls cleanup behavior for temporary files created when sending attachments
 */
interface TempFileConfig {
    /** File retention time in milliseconds (default: 10 minutes) */
    readonly maxAge?: number;
    /** Cleanup interval in milliseconds (default: 5 minutes) */
    readonly cleanupInterval?: number;
}
/**
 * SDK main configuration interface
 *
 * All options are optional and use default values
 */
interface IMessageConfig {
    /**
     * Database path
     * Default: ~/Library/Messages/chat.db
     */
    readonly databasePath?: string;
    /** Webhook configuration (optional) */
    readonly webhook?: WebhookConfig;
    /** Watcher configuration (optional) */
    readonly watcher?: WatcherConfig;
    /** Retry configuration (optional) */
    readonly retry?: RetryConfig;
    /** Temporary file configuration (optional) */
    readonly tempFile?: TempFileConfig;
    /**
     * AppleScript execution timeout
     * In milliseconds (default: 30000)
     */
    readonly scriptTimeout?: number;
    /**
     * Maximum concurrent sends
     * Default: 5, 0 means unlimited
     */
    readonly maxConcurrent?: number;
    /** Debug mode (default: false) */
    readonly debug?: boolean;
    /** Plugin list (optional) */
    readonly plugins?: readonly Plugin[];
}
/**
 * Resolved configuration
 *
 * All fields are populated with default values, guaranteed non-null
 */
interface ResolvedConfig {
    readonly databasePath: string;
    readonly webhook: WebhookConfig | null;
    readonly watcher: Required<WatcherConfig>;
    readonly retry: Required<RetryConfig>;
    readonly tempFile: Required<TempFileConfig>;
    readonly scriptTimeout: number;
    readonly maxConcurrent: number;
    readonly debug: boolean;
}

/**
 * Message Sender
 */

/** Send result */
interface SendResult {
    readonly sentAt: Date;
}
/** Send options */
interface SendOptions {
    /** Recipient */
    readonly to: string | Recipient;
    /** Text content */
    readonly text?: string;
    /** Attachments */
    readonly attachments?: readonly string[];
    /** Abort signal (optional) */
    readonly signal?: AbortSignal;
}
/**
 * Message Sender Class
 */
declare class MessageSender {
    /** Debug mode */
    private readonly debug;
    /** Maximum retry attempts */
    private readonly maxRetries;
    /** Retry delay */
    private readonly retryDelay;
    /** Concurrency limiter */
    private readonly semaphore;
    /** AppleScript timeout */
    private readonly scriptTimeout;
    constructor(debug?: boolean, retryConfig?: Required<RetryConfig>, maxConcurrent?: number, scriptTimeout?: number);
    /**
     * Execute script with retry
     *
     * @param script AppleScript code
     * @param description Operation description
     * @returns Execution result
     */
    private executeWithRetry;
    /**
     * Resolve attachment path
     * - Download network images (HTTP URL) → ~/Pictures/imsg_temp_*
     * - Validate local file path
     * - Auto-convert incompatible formats (AVIF/WebP -> JPEG) → ~/Pictures/imsg_temp_*
     *
     * Note: All temporary files are automatically named imsg_temp_* and stored in ~/Pictures
     *       TempFileManager will automatically scan and clean up these files, no manual tracking needed
     *
     * @param path Attachment path (local path or HTTP URL)
     * @returns Local path
     */
    private resolveAttachment;
    /**
     * Send message
     */
    send(options: SendOptions): Promise<SendResult>;
    /**
     * Check abort signal
     */
    private checkAbortSignal;
    /**
     * Check Messages environment
     */
    private checkMessagesEnvironment;
    /**
     * Prepare all attachments (download, convert)
     */
    private prepareAttachments;
    /**
     * Execute send strategy
     */
    private executeSendStrategy;
    /**
     * Send message (internal implementation)
     */
    private sendInternal;
    text(to: string | Recipient, text: string): Promise<SendResult>;
    image(to: string | Recipient, imagePath: string): Promise<SendResult>;
    textWithImages(to: string | Recipient, text: string | undefined, imagePaths: string[]): Promise<SendResult>;
}

/**
 * Message Processing Chain
 */

/**
 * Message Processing Chain
 *
 * Note: You must explicitly call execute() to perform operations
 *
 * @example
 * ```ts
 * await sdk.message(msg)
 *   .ifFromOthers()
 *   .matchText('hello')
 *   .replyText('Hi!')
 *   .execute()  // Must call execute()
 * ```
 */
declare class MessageChain {
    /** Message */
    private readonly message;
    /** Sender */
    private readonly sender;
    /** Whether to execute */
    private shouldExecute;
    /** Actions */
    private actions;
    /** Whether already executed */
    private executed;
    constructor(
    /** Message */
    message: Message, 
    /** Sender */
    sender: MessageSender);
    /**
     * Conditional check
     */
    when(predicate: Predicate<Message>): this;
    /**
     * Match text pattern
     */
    matchText(pattern: string | RegExp): this;
    /**
     * Only process unread messages
     */
    ifUnread(): this;
    /**
     * Only process messages from others
     */
    ifFromOthers(): this;
    /**
     * Only process my own messages
     */
    ifFromMe(): this;
    /**
     * Only process group chat messages
     */
    ifGroupChat(): this;
    /**
     * Reply with text
     */
    replyText(text: string | Mapper<Message, string>): this;
    /**
     * Reply with image
     */
    replyImage(images: string | string[] | Mapper<Message, string | string[]>): this;
    /**
     * Execute custom operation
     */
    do(handler: (message: Message) => void | Promise<void>): this;
    /**
     * Execute all operations (explicit call)
     *
     * This is the only method that actually performs operations
     *
     * @throws If an error occurs during execution
     */
    execute(): Promise<void>;
}

/**
 * Database Access Layer
 *
 * - Query message history (with multiple filter options)
 * - Read message attachment information
 * - Support all message types (iMessage, SMS, RCS)
 * - Support both Bun and Node.js runtimes
 */

/**
 * Read-only access to macOS Messages app SQLite database
 */
declare class IMessageDatabase {
    /** SQLite database instance */
    private db;
    /** macOS epoch time (timestamp of 2001-01-01) */
    private readonly MAC_EPOCH;
    /** Initialization promise */
    private initPromise;
    /**
     * Open iMessage database
     * @param path Database file path
     * @throws DatabaseError When database fails to open
     */
    constructor(path: string);
    /**
     * Initialize database (async)
     */
    private init;
    /**
     * Ensure database is initialized before any operation
     */
    private ensureInit;
    /**
     * Query messages (with multiple filter options)
     *
     * @param filter Filter conditions (optional)
     * @returns Message query result (includes message list and statistics)
     * @throws DatabaseError When query fails
     *
     * @example Query all unread messages
     * ```ts
     * const result = await db.getMessages({ unreadOnly: true })
     * ```
     *
     * @example Query messages from specific sender
     * ```ts
     * const result = await db.getMessages({
     *   sender: '+1234567890',
     *   limit: 20
     * })
     * ```
     *
     * @example Query recent messages with attachments
     * ```ts
     * const result = await db.getMessages({
     *   hasAttachments: true,
     *   since: new Date('2024-01-01'),
     *   limit: 10
     * })
     * ```
     */
    getMessages(filter?: MessageFilter): Promise<MessageQueryResult>;
    /**
     * Get unread messages grouped by sender
     *
     * @returns Map where key is sender identifier and value is array of messages from that sender
     *
     * @example
     * ```ts
     * const grouped = await db.getUnreadMessages()
     * for (const [sender, messages] of grouped) {
     *   console.log(`${sender}: ${messages.length} unread messages`)
     * }
     * ```
     */
    getUnreadMessages(): Promise<Map<string, Message[]>>;
    /**
     * Get all attachments for specified message
     * @param messageId Message ID
     * @returns Array of attachments, returns empty array if no attachments
     */
    private getAttachments;
    /**
     * Convert database query result to Message object
     * @param row Raw row data from database query
     * @returns Formatted Message object
     */
    private rowToMessage;
    /**
     * Map service type string from database
     * @param service Service identifier from database
     * @returns Standardized service type
     */
    private mapService;
    /**
     * Convert macOS timestamp to JavaScript Date object
     *
     * macOS epoch starts at 2001-01-01, unit is nanoseconds
     * @param timestamp macOS timestamp
     * @returns JavaScript Date object
     */
    private convertMacTimestamp;
    /**
     * Close database connection
     */
    close(): Promise<void>;
}

/**
 * Message Watcher
 */

/** Message callback */
type MessageCallback = (message: Message) => void | Promise<void>;
/** Watcher event callbacks */
interface WatcherEvents {
    /** Triggered when new 1-on-1 message arrives */
    onNewMessage?: MessageCallback;
    /** Triggered when new group chat message arrives (optional, ignored by default) */
    onGroupMessage?: MessageCallback;
    /** Triggered when error occurs */
    onError?: (error: Error) => void;
}

/**
 * IMessage SDK - Type-safe macOS iMessage SDK
 *
 * @example
 * ```typescript
 * import { IMessageSDK, loggerPlugin } from '@photon-ai/imessage-kit'
 *
 * const sdk = new IMessageSDK({
 *   plugins: [loggerPlugin()]
 * })
 *
 * /// Send messages
 * await sdk.send('+1234567890', 'Hello!')
 * await sdk.send('+1234567890', { images: ['photo.jpg'] })
 *
 * /// Chain processing
 * await sdk.message(msg)
 *   .ifFromOthers()
 *   .matchText('hello')
 *   .replyText('Hi!')
 *   .execute()
 * ```
 */

/** SDK dependency injection interface */
interface SDKDependencies {
    database?: IMessageDatabase;
    sender?: MessageSender;
    pluginManager?: PluginManager;
}
/** IMessage SDK Core Class */
declare class IMessageSDK {
    /** Configuration */
    private readonly config;
    /** Database */
    private readonly database;
    /** Temporary file manager */
    private readonly tempFileManager;
    /** Message sender */
    private readonly sender;
    /** Plugin manager */
    private readonly pluginManager;
    /** Message watcher */
    private watcher;
    /** Whether destroyed */
    private destroyed;
    constructor(config?: IMessageConfig, dependencies?: SDKDependencies);
    private ensurePluginsReady;
    private resolveConfig;
    /** Generic wrapper for sending messages */
    private sendWithHooks;
    /**
     * Register plugin
     */
    use(plugin: Plugin): this;
    /**
     * Get plugin manager
     * @returns PluginManager instance
     */
    get plugins(): PluginManager;
    /**
     * Query messages
     */
    getMessages(filter?: MessageFilter): Promise<MessageQueryResult>;
    /**
     * Get unread messages (grouped by sender)
     */
    getUnreadMessages(): Promise<Array<{
        sender: string;
        messages: Message[];
    }>>;
    /**
     * Send message
     *
     * @example
     * ```ts
     * await sdk.send(phone, 'Hello')
     * await sdk.send(phone, { images: ['/img.jpg'] })
     * await sdk.send(phone, { text: 'Hi', images: ['/img.jpg'] })
     * await sdk.send(phone, { files: ['/document.pdf', '/contact.vcf'] })
     * await sdk.send(phone, { text: 'Check this', files: ['/data.csv'] })
     * ```
     */
    send(to: string | Recipient, content: string | {
        text?: string;
        images?: string[];
        files?: string[];
    }): Promise<SendResult$1>;
    /**
     * Send batch messages (concurrency controlled by sender's maxConcurrent config)
     *
     * @param messages Batch message list
     * @returns List of send results (including success and failure)
     *
     * @example
     * ```ts
     * const results = await sdk.sendBatch([
     *   { to: '+1234567890', content: 'Hello' },
     *   { to: '+0987654321', content: 'Hi' },
     * ])
     *
     * for (const result of results) {
     *   if (result.success) {
     *     console.log('Send success:', result.to)
     *   } else {
     *     console.error('Send failed:', result.to, result.error)
     *   }
     * }
     * ```
     */
    sendBatch(messages: Array<{
        to: string | Recipient;
        content: string | {
            text?: string;
            images?: string[];
            files?: string[];
        };
    }>): Promise<Array<{
        to: string;
        success: boolean;
        result?: SendResult$1;
        error?: Error;
    }>>;
    /**
     * Send file (convenience method)
     *
     * @example
     * ```ts
     * await sdk.sendFile('+1234567890', '/path/to/document.pdf')
     * await sdk.sendFile('+1234567890', '/path/to/contact.vcf', 'Here is the contact')
     * ```
     */
    sendFile(to: string | Recipient, filePath: string, text?: string): Promise<SendResult$1>;
    /**
     * Send multiple files (convenience method)
     *
     * @example
     * ```ts
     * await sdk.sendFiles('+1234567890', ['/file1.pdf', '/file2.csv'])
     * await sdk.sendFiles('+1234567890', ['/data.xlsx'], 'Check these files')
     * ```
     */
    sendFiles(to: string | Recipient, filePaths: string[], text?: string): Promise<SendResult$1>;
    /**
     * Create message processing chain
     */
    message(message: Message): MessageChain;
    /**
     * Start watching for new messages
     */
    startWatching(events?: WatcherEvents): Promise<void>;
    /**
     * Stop watching for new messages
     */
    stopWatching(): void;
    /**
     * Close SDK and release resources
     */
    close(): Promise<void>;
    /** Support using declaration (TypeScript 5.2+) */
    [Symbol.asyncDispose](): Promise<void>;
    /** Support using declaration (sync version) */
    [Symbol.dispose](): void;
}

/**
 * Logger Plugin
 */

/**
 * Log level
 */
type LogLevel = 'debug' | 'info' | 'warn' | 'error';
/**
 * Logger plugin options
 */
interface LoggerOptions {
    /** Log level (default: info) */
    level?: LogLevel;
    /** Whether to use colored output (default: true) */
    colored?: boolean;
    /** Whether to show timestamps (default: false) */
    timestamp?: boolean;
    /** Whether to log send operations (default: true) */
    logSend?: boolean;
    /** Whether to log new messages (default: false) */
    logNewMessage?: boolean;
}
/**
 * Create a logger plugin
 *
 * @param options Logger configuration (optional)
 * @returns Plugin instance
 *
 * @example Basic usage
 * ```ts
 * const sdk = new IMessageSDK({
 *   plugins: [loggerPlugin()]  // Use default configuration
 * })
 * ```
 *
 * @example Custom configuration
 * ```ts
 * const sdk = new IMessageSDK({
 *   plugins: [
 *     loggerPlugin({
 *       level: 'info',        // Only show info and above
 *       colored: true,        // Colored output
 *       timestamp: true,      // Show timestamps
 *       logSend: true,        // Log send operations
 *       logNewMessage: true   // Log new messages
 *     })
 *   ]
 * })
 * ```
 *
 * @example Production configuration
 * ```ts
 * const sdk = new IMessageSDK({
 *   plugins: [
 *     loggerPlugin({
 *       level: 'warn',        // Only show warnings and errors
 *       colored: false,       // Plain text output
 *       logSend: false        // Don't log send operations
 *     })
 *   ]
 * })
 * ```
 */
declare const loggerPlugin: (options?: LoggerOptions) => Plugin;

/**
 * SDK Error Types
 */
/** Error code types */
type ErrorCode = 'PLATFORM' | 'DATABASE' | 'SEND' | 'WEBHOOK' | 'CONFIG' | 'UNKNOWN';
/**
 * Unified SDK Error Class
 */
declare class IMessageError extends Error {
    readonly code: ErrorCode;
    constructor(code: ErrorCode, message: string);
    /** Type guard */
    static is(error: unknown): error is IMessageError;
    /** Check if error is of specific type */
    is(code: ErrorCode): boolean;
}
/** Factory functions */
declare const PlatformError: (msg?: string) => IMessageError;
declare const DatabaseError: (msg: string) => IMessageError;
declare const SendError: (msg: string) => IMessageError;
declare const WebhookError: (msg: string) => IMessageError;
declare const ConfigError: (msg: string) => IMessageError;

/**
 * Platform check utilities
 */

/**
 * Check and require running on macOS platform
 *
 * @throws PlatformError when not macOS
 */
declare const requireMacOS: () => void;
/**
 * Check if current system is macOS
 *
 * @returns true if macOS
 */
declare const isMacOS: () => boolean;

export { type Attachment, ConfigError, DatabaseError, type ErrorCode, type IMessageConfig, IMessageError, IMessageSDK, type LoggerOptions, type Mapper, type Message, MessageChain, type MessageFilter, type MessageQueryResult, PlatformError, type Plugin, type PluginHooks, type Predicate, type Recipient, type ResolvedConfig, type RetryConfig, SendError, type SendResult$1 as SendResult, type ServiceType, type TempFileConfig, type WatcherConfig, type WatcherEvents, type WebhookConfig, WebhookError, asRecipient, definePlugin, isMacOS, loggerPlugin, requireMacOS };
